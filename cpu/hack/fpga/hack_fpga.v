/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module clkdiv20 (
    input clk,
    output reg clk_out = 0
);

  reg [31:0] counter = 0;

  localparam COUNT = 675000;

  always @(posedge clk) begin
    if (counter == COUNT) begin
      counter <= 0;
      clk_out <= ~clk_out;
    end else counter <= counter + 1;
  end

endmodule

module clkdiv120 (
    input clk,
    output reg clk_out = 0
);

  reg [31:0] counter = 0;

  localparam COUNT = 112500;

  always @(posedge clk) begin
    if (counter == COUNT) begin
      counter <= 0;
      clk_out <= ~clk_out;
    end else counter <= counter + 1;
  end

endmodule


module DIG_Counter_Nbit
#(
    parameter Bits = 2
)
(
    output [(Bits-1):0] out,
    output ovf,
    input C,
    input en,
    input clr
);
    reg [(Bits-1):0] count;

    always @ (posedge C) begin
        if (clr)
          count <= 'h0;
        else if (en)
          count <= count + 1'b1;
    end

    assign out = count;
    assign ovf = en? &count : 1'b0;

    initial begin
        count = 'h0;
    end
endmodule

`include "cpu.v"
`include "roma.v"

module hack (
    input clk,
    input rstn,
    output [15:0] SCREEN
);
  wire [14:0] rom_addr;
  wire [15:0] rom_data;
  // ROM
  ROMA ROMA_i0 (
      .A(rom_addr),
      .D(rom_data)
  );
  // cpu
  cpu cpu_i1 (
      .instr(rom_data),
      .clk(clk),
      .rstn(rstn),
      .PC(rom_addr),
      .SCREEN(SCREEN)
  );
endmodule

module bcd (
    input [15:0] bin,
    output reg [15:0] bcd
);

  integer i;

  always @(bin) begin
    bcd = 0;
    for (i = 0; i < 16; i = i + 1) begin  //Iterate once for each bit in input number
      if (bcd[3:0] >= 5) bcd[3:0] = bcd[3:0] + 3;  //If any BCD digit is >= 5, add three
      if (bcd[7:4] >= 5) bcd[7:4] = bcd[7:4] + 3;
      if (bcd[11:8] >= 5) bcd[11:8] = bcd[11:8] + 3;
      if (bcd[15:12] >= 5) bcd[15:12] = bcd[15:12] + 3;
      bcd = {bcd[14:0], bin[13-i]};  //Shift one bit, and shift in proper bit from input 
    end
  end
endmodule


module Decoder2 (
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    input [1:0] sel
);
    assign out_0 = (sel == 2'h0)? 1'b1 : 1'b0;
    assign out_1 = (sel == 2'h1)? 1'b1 : 1'b0;
    assign out_2 = (sel == 2'h2)? 1'b1 : 1'b0;
    assign out_3 = (sel == 2'h3)? 1'b1 : 1'b0;
endmodule


module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module sevseg (
    input [3:0] in,
    output reg [6:0] pattern
);

  always @(in) begin
    case (in)
      4'd0: pattern <= 7'b0111111;
      4'd1: pattern <= 7'b0000110;
      4'd2: pattern <= 7'b1011011;
      4'd3: pattern <= 7'b1001111;
      4'd4: pattern <= 7'b1100110;
      4'd5: pattern <= 7'b1101101;
      4'd6: pattern <= 7'b1111101;
      4'd7: pattern <= 7'b0000111;
      4'd8: pattern <= 7'b1111111;
      4'd9: pattern <= 7'b1101111;
      default: pattern <= 7'b0000000;

    endcase
  end
endmodule


module hack_fpga (
  input clk,
  input btn1,
  output a,
  output b,
  output c,
  output d,
  output e,
  output f,
  output g,
  output x0,
  output x1,
  output x2,
  output x3
);
  wire [3:0] s0;
  wire [6:0] s1;
  wire [6:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [1:0] s5;
  wire [3:0] s6;
  wire [3:0] s7;
  wire [3:0] s8;
  wire [3:0] s9;
  wire s10;
  wire s11;
  // clkdiv20
  clkdiv20 clkdiv20_i0 (
    .clk( clk ),
    .clk_out( s11 )
  );
  // clkdiv120
  clkdiv120 clkdiv120_i1 (
    .clk( clk ),
    .clk_out( s10 )
  );
  DIG_Counter_Nbit #(
    .Bits(2)
  )
  DIG_Counter_Nbit_i2 (
    .en( 1'b1 ),
    .C( s10 ),
    .clr( 1'b0 ),
    .out( s5 )
  );
  // hack
  hack hack_i3 (
    .clk( s11 ),
    .rstn( btn1 ),
    .SCREEN( s3 )
  );
  // bcd
  bcd bcd_i4 (
    .bin( s3 ),
    .bcd( s4 )
  );
  Decoder2 Decoder2_i5 (
    .sel( s5 ),
    .out_0( x0 ),
    .out_1( x1 ),
    .out_2( x2 ),
    .out_3( x3 )
  );
  assign s6 = s4[3:0];
  assign s7 = s4[7:4];
  assign s8 = s4[11:8];
  assign s9 = s4[15:12];
  Mux_4x1_NBits #(
    .Bits(4)
  )
  Mux_4x1_NBits_i6 (
    .sel( s5 ),
    .in_0( s6 ),
    .in_1( s7 ),
    .in_2( s8 ),
    .in_3( s9 ),
    .out( s0 )
  );
  // sevseg
  sevseg sevseg_i7 (
    .in( s0 ),
    .pattern( s1 )
  );
  assign s2 = ~ s1;
  assign a = s2[0];
  assign b = s2[1];
  assign c = s2[2];
  assign d = s2[3];
  assign e = s2[4];
  assign f = s2[5];
  assign g = s2[6];
endmodule
